# 백엔드 패키징 결정 과정 (2025‑07‑29)

## 고민 플로우

- **팀 규모**: 백엔드 2명 → 의사결정·리팩터링 비용 최소화 필요
- **확장성**: REST 이외에 SSE·gRPC 등 추가 가능성 존재
- **사용자 타입**: Member(고령자,보호자) / Admin(센터,종사자) 분리
- **도메인 복잡도**: Record, Report 같은 주요 기능이 빠르게 늘어날 전망
- **개발 속도 vs 품질**: 초기 과설계 지양, 추후 확장성 고려

## 방안
### 1. 전통적인 레이어드 아키텍처

#### 특징
- 기술 계층 중심 구조 (예: `Controller → Service → Repository → DB`)
- Spring에서 가장 일반적으로 사용되는 구조
- CRUD 중심의 단순한 흐름에 적합

#### 장점
- 빠른 개발 가능, 학습 및 유지보수 용이
- 팀원 간 역할 분담이 직관적
- 프레임워크와 잘 통합됨

#### 단점
- 다양한 입출력 채널(SSE, 비동기 워커 등) 도입 시 구조가 불분명해짐
- 사용자 유형에 따른 흐름 분리 어려움 (member/admin)
- 기술 의존성이 도메인 로직과 뒤섞이기 쉬움
- 테스트 및 변경에 유연하지 않음

---

### 헥사고날 아키텍처 (Hexagonal Architecture)

#### 특징
- 도메인 로직을 중심으로 외부와의 입출력(Port/Adapter)을 명확히 분리
- 입출력 경계를 `in` / `out` 어댑터로 구분하여 책임을 분리
- 기술 독립성, 테스트 용이성, 확장성을 목표로 함

#### 장점
- 도메인 순수성 유지
- 다양한 입출력 채널 대응에 강함 (SSE, 이벤트 수신 등)
- 테스트 및 모킹 용이
- 멀티모듈, MSA 구조로의 이행 용이

#### 단점
- 설계 및 구현 복잡도 증가
- 소규모 팀, 빠른 개발 단계에서는 과설계가 될 수 있음
- 추상화 구조를 유지하는 데 추가적인 관리 비용 발생

---

### 우리 상황 분석

#### 현재 상황
- 백엔드 팀 인원 2명 (소규모 팀)
- 사용자 유형 명확: `member`(보호자) / `admin`(센터 종사자)
    - 사용하는 API와 비즈니스 플로우가 명확히 다름
    - adapter / application 단에서 분리 필요

#### 향후 예상 흐름

리포트 생성 시나리오

1. 클라이언트 → API 서버: 리포트 생성 요청
2. API 서버 → Redis Stream: 비동기 워커 트리거
3. 워커: LLM 호출, 리포트 생성
4. 워커 → DB: 리포트 저장
5. 워커 → API 서버: 생성 완료 알림
6. API 서버 → 클라이언트: SSE로 완료 알림

OCR 요청 흐름

- 리포트 생성과 거의 동일, LLM 대신 OCR 모델 사용

문자 전송

- 워커 내에서 직접 문자 전송 수행
- 필요 시 SSE로 사용자에게 전송 결과 전달

---

### 최종 구조 결정

> **전통적인 레이어드 아키텍처를 기반으로 하되,  
헥사고날 아키텍처의 '입출력 책임 분리' 철학을 부분적으로 차용한 구조를 채택한다.**

---

### 결정 근거

#### 사용자 유형 분리
- member / admin의 비즈니스 흐름과 API 구조가 명확히 다름
- adapter / application 계층에서 사용자 기준 분리를 통해 책임 범위 최소화

#### 입출력 확장 대응
- REST 외에도 SSE, 비동기 워커(별도 모듈)와의 통신 흐름이 예정되어 있음
- 어댑터 계층에 `sse/`, `worker/` 디렉토리 구조를 고려해 유연하게 확장 가능

#### 기술 의존성 분리
- Redis Stream, SSE Emitter, 외부 API 호출 등은 infrastructure 계층에 분리
- application은 인터페이스만 알고 호출 → 헥사고날의 port 개념을 간접적으로 반영

#### 구조의 단순성과 현실성
- 포트/어댑터 전면 도입 없이도 헥사고날의 장점 일부 확보
- 초기 개발 부담 최소화 + 테스트/확장 유연성 확보

---

### 정리

> 지금은 단순하게, 나중엔 유연하게.  
전통적인 레이어드 아키텍처의 익숙함과 헥사고날 아키텍처의 구조적 강점을 조화롭게 흡수한  
**현실적인 아키텍처 전략**으로,  
사용자 분리, 입출력 채널 확장, 기술 관심사 분리를 효과적으로 반영한 구조다.

---

```text
adapter/
  member/
  admin/

application/
  member/
  admin/

domain/
  entity/
  service/
  model/

infrastructure/
  jpa/
```

## 추후 패키지 구조

infrastructure/ 하위에 cache/, messaging/, file/ 등 기술 스택 확장에 따른 모듈 분리 고려

domain/ 하위 모델 수 증가 시 record/, report/ 등 도메인 중심으로 세분화

application/ 하위에도 도메인 기반으로 슬라이스 분할 가능 (예: user/record, admin/report 등)



### TODO
- `adapter/`하위에 User/Admin RestController (Swagger로 문서화)
- swagger‑ui로 팀 검토
- application/*/facade 및 주요 UseCase 인터페이스 skeleton 생성
- infrastructure/jpa 에 Spring Data JPA repository 구현

