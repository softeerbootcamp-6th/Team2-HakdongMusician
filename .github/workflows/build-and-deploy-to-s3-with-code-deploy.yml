name: Build and Deploy to S3 with CodeDeploy

on:
  push:
    branches: [ "main", "back-develop" ]
    paths:
      - 'daycan-back/**'
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: ap-northeast-2
  S3_BUCKET: ${{ secrets.S3_BUCKET }}
  CODEDEPLOY_APP: ${{ secrets.CODEDEPLOY_APP }}
  CODEDEPLOY_GROUP: ${{ secrets.CODEDEPLOY_GROUP }}

jobs:
  build-and-upload:
    runs-on: ubuntu-latest

    defaults:
      run:
        working-directory: daycan-back/api

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Amazon Corretto 17
        uses: actions/setup-java@v4
        with:
          distribution: corretto
          java-version: '17'
          cache: 'gradle'

      - name: Grant execute permission for gradlew
        run: |
          if [ -f gradlew ]; then
            chmod +x gradlew
            echo "✅ Made gradlew executable"
          else
            echo "❌ gradlew not found in current directory"
            exit 1
          fi

      # TODO: 테스트 단계 추가
      - name: Build with Gradle
        run: |
          echo "🔨 Building Spring Boot application (api module)..."
          ./gradlew clean bootJar
          echo "✅ Build completed successfully!"

      - name: Make daycan.env file
        working-directory: daycan-back
        run: |
          cat > daycan.env <<'EOF'
          DB_HOST=${{ secrets.DB_HOST }}
          DB_PORT=3306
          DB_USERNAME=${{ secrets.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          SPRING_PROFILES_ACTIVE=develop
          DAYCAN_PORT=8080
          TZ=Asia/Seoul

          JAVA_XMS=-Xms256m
          JAVA_XMX=-Xmx512m
          JAVA_GC=-XX:+UseG1GC
          JAVA_OOM=-XX:+ExitOnOutOfMemoryError
          JAVA_HEAPDUMP=-XX:HeapDumpPath=/var/log/daycan/heapdump.hprof
          JAVA_GCLOG=-Xlog:gc*:file=/var/log/daycan/gc.log:time,uptime,level,tags

          JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}
          OPEN_AI_KEY=${{ secrets.OPEN_AI_KEY }}
          OPEN_AI_URL=${{ secrets.OPEN_AI_URL }}
          CLOVA_URL=${{ secrets.CLOVA_URL }}
          CLOVA_KEY=${{ secrets.CLOVA_KEY }}
          APP_AWS_REGION=${{ secrets.APP_AWS_REGION }}
          APP_S3_BUCKET=${{ secrets.APP_S3_BUCKET }}
          EOF
          echo "✅ daycan.env file created successfully!"

      - name: Validate env format (no leading spaces / bad lines)
        working-directory: daycan-back
        run: |
          sed -n '1,200p' daycan.env
          if awk '/^[[:space:]]+[^#]/ {print "ERR: leading spaces at line", NR; bad=1} END{exit bad}' daycan.env; then
            echo "✅ No leading spaces"
          else
            echo "❌ Leading spaces found in env lines"
            exit 1
          fi
          if grep -nE '^[[:space:]]*-[Xx]+' daycan.env; then
            echo "Invalid standalone JVM option lines found"
            exit 1
          fi

      - name: Prepare CodeDeploy bundle
        working-directory: daycan-back/api
        run: |
          echo "📋 Preparing CodeDeploy deployment bundle..."
          TIMESTAMP=$(date +'%Y%m%d-%H%M%S')
          COMMIT_HASH=${GITHUB_SHA::7}
          JAR_FILE=$(ls -t build/libs/*.jar | grep -v 'plain.jar' | head -n 1)

          mkdir -p deployment-bundle/app
          mkdir -p deployment-bundle/scripts

          cp "$JAR_FILE" deployment-bundle/app/app.jar
          echo "✅ Copied JAR file to deployment bundle"

          cp ../appspec.yml deployment-bundle/
          cp ../daycan.env deployment-bundle/
          cp -r ../scripts/* deployment-bundle/scripts/
          echo "✅ Copied appspec.yml and scripts"

          chmod +x deployment-bundle/scripts/*.sh

          BUNDLE_NAME="daycan-back-${TIMESTAMP}-${COMMIT_HASH}.zip"
          cd deployment-bundle
          zip -r "../$BUNDLE_NAME" .
          cd ..

          echo "UPLOAD_FILE=$BUNDLE_NAME" >> $GITHUB_ENV
          echo "S3_KEY=deploy/daycan-back/$BUNDLE_NAME" >> $GITHUB_ENV
          echo "DEPLOYMENT_ID=${TIMESTAMP}-${COMMIT_HASH}" >> $GITHUB_ENV
          echo "✅ CodeDeploy bundle prepared: $BUNDLE_NAME"

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Upload deployment bundle to S3
        run: |
          echo "📤 Uploading deployment bundle to S3..."
          aws s3 cp "$UPLOAD_FILE" "s3://${S3_BUCKET}/${S3_KEY}"
          echo "✅ Successfully uploaded to: s3://${S3_BUCKET}/${S3_KEY}"

      - name: Create CodeDeploy deployment
        id: deploy
        run: |
          echo "🚀 Creating CodeDeploy deployment..."
          DEPLOYMENT_ID_RESULT=$(aws deploy create-deployment \
            --application-name "${CODEDEPLOY_APP}" \
            --deployment-group-name "${CODEDEPLOY_GROUP}" \
            --revision "revisionType=S3,s3Location={bucket=${S3_BUCKET},key=${S3_KEY},bundleType=zip}" \
            --description "Deploy ${GITHUB_SHA} from ${GITHUB_REF_NAME} (${DEPLOYMENT_ID})" \
            --query "deploymentId" --output text)

          echo "CODEDEPLOY_ID=$DEPLOYMENT_ID_RESULT" | tee -a $GITHUB_ENV
          echo "deployment_id=$DEPLOYMENT_ID_RESULT" >> $GITHUB_OUTPUT
          echo "✅ CodeDeploy deployment created: $DEPLOYMENT_ID_RESULT"

      - name: Deployment summary
        run: |
          echo "🎯 Deployment Summary:"
          echo "- Application: ${CODEDEPLOY_APP}"
          echo "- Deployment Group: ${CODEDEPLOY_GROUP}"
          echo "- Deployment ID: ${CODEDEPLOY_ID:-N/A}"
          echo "- S3 Bundle: s3://${S3_BUCKET}/${S3_KEY}"
          echo "- Build Time: $(date)"
          echo "- Commit: ${GITHUB_SHA}"
          echo "- Branch: ${GITHUB_REF_NAME}"